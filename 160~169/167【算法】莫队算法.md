**莫队算法**适用于：若存在一个长度为 $n$ 的序列，对于序列上的 $m$ 个区间询问问题，如果一个区间答案能够在 $O(1)$ 转移到相邻区间的答案，那么可以通过莫队算法在 $O(n\sqrt m)$ 的复杂度求出所有询问。

对于区间 $[l,r]$，它的相邻区间定义为：

- $[l-1,r]$
- $[l+1,r]$
- $[l,r-1]$
- $[l,r+1]$

<!--more-->

## 原理

将所有询问区间 $[l,r]$ 离线后排序，首先按第一关键字 $l$ 排序，然后按第二关键字 $r$ 排序。然后按顺序处理询问，对于首个区间询问的答案，通过暴力计算取得。之后的答案基于上一个区间 $[l,r]$ 的答案，通过暴力一步一步转移，得到下一个区间 $[l',r']$ 的答案。

代码框架如下：

```cpp
int cur_ans = 0; // current answer
void add(int pos) { /* update current answer */ }
void del(int pos) { /* update current answer */ }

void solve()
{
    sort(query.begin(), query.end());
    int l = 1, r = 0; // initial
    for (int i = 0; i < m; i++)
    {
		while (l > query[i].l) add(--l);
        while (r < query[i].r) add(++r);
        while (l < query[i].l) del(l++);
        while (r > query[i].r) del(r--);   
        ans[query[i].idx] = cur_ans;
    }
}
```

每一次转移时包含了四个循环，需要注意循环的顺序很关键，随意修改可能会**导致错误**。循环排列顺序共 $24$ 种，其中只有 $6$ 种是正确的，上面则为其中一种：`l--, r++, l++, r--`

之所以有些顺序是错误的，是因为它们会导致 $l>r+1$ 的情况，这将导致元素加入次数为负数，产生异常。

上面这种的正确性可以这样思考，`l--, r++` 首先将区间扩大，`l++, r--` 然后将区间缩小直到缩小为 $[l',r']$ ，全程可以保证 $l\leq r+1$.

## 优化

考虑一种询问情况，排序后如下：

```
1 2
1 3
...
1 999
1 1000
2 3
2 4
...
2 999
2 1000
```

我们模拟一下上面的情况，可以发现总移动次数约为 $3000$ 次，左右指针的移动过程如下图：

![](https://assets.zouht.com/img/note/167-01.webp)

从 $l=1$ 到 $l=2$ 的转换过程中，$r$ 指针从 $1000$ 左移到 $3$，在 $l=2$ 的区间计算过程中，$r$ 指针又从 $3$ 左移到了 $1000$.

我们可以很明显的发现，$r$ 指针浪费了很多时间，它完全可以在从右往左返回时顺便把 $l=2$ 的询问给计算了，过程如下：

![](https://assets.zouht.com/img/note/167-02.webp)

可以发现，如果按优化后的策略，总移动次数约为 $2000$ 次，优化程度高达约 $33\%$.

将上面的思路转化为代码实现，流程即为：

- 设块长度为 $S$，则可以将 $m$ 个区间分为 $\frac{m}{S}$ 个块
- 在每一块中分别排序：
  - 对于编号奇数的块：第一关键字 $l$ 升序，第二关键字 $r$ 升序
  - 对于编号偶数的块：第一关键字 $l$ 升序，第二关键字 $r$ 降序

取 $S=\sqrt m$ 时最佳。

转换成 `cmp` 函数则为：

```cpp
int block;
bool cmp(Query a, Query b)
{
    if (a.l / block != b.l / block)
        return a.l < b.l;
    return (a.l / block) % 2 ? a.r < b.r : a.r > b.r;
}
```

上面的例子虽说是一个构造的特例，但是实际上一般情况，这种优化也是能让程序快 $30\%$ 左右的。

## 代码

模板题：[Luogu P1494 [国家集训队] 小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)

```cpp
struct tup {
    int id, l, r;
};

void solve() {
    int n, m;
    cin >> n >> m;
    int block = sqrt(n);
    vector<int> c(n + 10);
    for (int i = 1; i <= n; i++)
        cin >> c[i];
    vector<tup> query(m + 10);
    for (int i = 1; i <= m; i++) {
        cin >> query[i].l >> query[i].r;
        query[i].id = i;
    }
    sort(query.begin() + 1, query.begin() + 1 + m, [block](tup a, tup b) -> bool {
        if (a.l / block != b.l / block)
            return a.l < b.l;
        return (a.l / block) % 2 ? a.r < b.r : a.r > b.r;
    });
    vector<pair<int, int>> ans(m + 10);
    int cur = 0;
    vector<int> cnt(n + 10);
    auto add = [&](int x) -> void {
        cur += cnt[x];
        cnt[x]++;
    };
    auto del = [&](int x) -> void {
        cnt[x]--;
        cur -= cnt[x];
    };
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        if (query[i].l == query[i].r) {
            ans[query[i].id] = {0, 1};
            continue;
        }
        while (l > query[i].l) add(c[--l]);
        while (r < query[i].r) add(c[++r]);
        while (l < query[i].l) del(c[l++]);
        while (r > query[i].r) del(c[r--]);
        ans[query[i].id] = {cur, (r - l + 1) * (r - l) / 2};
    }
    for (int i = 1; i <= m; i++) {
        auto &[a, b] = ans[i];
        if (a == 0) {
            cout << "0/1" << endl;
            continue;
        }
        int g = gcd(a, b);
        cout << a / g << '/' << b / g << endl;
    }
}
```

用莫队的关键点就是找相邻区间的递推方式，对于本题来说，区间的变化分为两种：变长、变短。

如果区间变长（`l-- / r++`），则代表区间会加入颜色为 $c_x$ 的这双袜子，如果这双袜子在原区间内有 $\text{cnt}(c_x)$ 双，**分子**（合法选法总数）的变化则为：
$$
ans_{\text{new}} = ans_{\text{old}} + \binom{\text{cnt}(c_x)+1}{2} - \binom{\text{cnt}(c_x)}{2} = ans_{\text{old}} + \text{col}(c_x)
$$
注意同时更新 $\text{cnt}(c_x)$ 的数目。除以**分母**（选法总数）便得到了这个询问的答案：
$$
\frac{ans}{\binom{r-l+1}{2}}
$$
那么相反，如果区间变短（`l++ / r--`），则代表区间会去掉颜色为 $c_x$ 的这双袜子，符号反过来即可：
$$
ans_{\text{new}} = ans_{\text{old}} - \binom{\text{cnt}(c_x)}{2} + \binom{\text{cnt}(c_x) - 1}{2} = ans_{\text{old}} - (\text{col}(c_x) - 1)
$$
