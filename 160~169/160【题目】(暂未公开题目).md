**(暂未公开场次)**

(暂未公开题目)

(暂未公开链接)

<!--more-->

1 second / 256 megabytes

standard input / standard output

## 题目

(暂未公开题目)

## 题解

词长度范围仅 $13$，很小，可以考虑状态压缩 DP. 使用 $13$ 位的二进制数表示状态，第 $i$ 位为 $1$ 代表该词已经被学习，反之没有，遍历 $2^{13}$ 个状态进行转移即可。

对于一个状态 $i$，它可以通过学习它的非空子集 $j$ 转移得到，学习前的状态为 $i\oplus j$.

例如对于 $i=0000000001011_2$，它可以通过七种学习方式 $0000000001011_2$，$0000000000011_2$，$0000000001001_2$，$0000000001010_2$，$0000000000001_2$，$0000000000010_2$，$0000000001000_2$ 转移得到。

遍历一个状态的非空子集的方式可以写作：`for (int j = i; j; j = (j - 1) & i)`

但是，如果一次学习的量超过 $w$，那么也是不成立的，因此每次需要判断学习的量有没有超标。可以预处理出来每种学习方式的数量。

## 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define int long long

using namespace std;

constexpr int MAXN = 13;
int cnt[MAXN];
int n, w;
int sum[1 << MAXN], dp[1 << MAXN];

void solve()
{
    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;
    cin >> n >> w;
    for (int i = 0; i < n; i++)
    {
        int t;
        cin >> t;
        cnt[t - 1]++;
    }
    for (int i = 0; i < (1 << MAXN); i++)
        for (int j = 0; j < MAXN; j++)
            if (i >> j & 1)
                sum[i] += cnt[j];
    for (int i = 0; i < (1 << MAXN); i++)
		for (int j = i; j; j = (j - 1) & i)
			if (sum[j] <= w)
				dp[i] = min(dp[i], dp[i ^ j] + 1);
	cout << dp[(1 << MAXN) - 1] << endl;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--)
        solve();
    return 0;
}
```

