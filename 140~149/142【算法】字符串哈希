**字符串哈希：**将字符串映射到一个整型哈希值的方式。

<!--more-->

## 字符串转整型

我们首先用进制转换举例。

$(1001)_2$ 这个二进制数转为十进制，即 $(1001)_2=1\cdot2^3+0\cdot2^2+0\cdot2^1+1\cdot2^0=9$ 

$(1234)_p$ 这个 $p$ 进制数转为十进制，即 $(1234)_p=1\cdot p^3+2\cdot p^2+3\cdot p^1+4\cdot p^0$

那么我们完全可以将字符串看为一个 $p$ 进制数，将其转换为十进制。该十进制数唯一对应这个字符串，这个字符串也唯一对应这个十进制数，如此便将字符串转换为了一个整型数。

经验规律得出，$p$ 的值取 $131$ 或 $13331$ 时冲突几率较小。因为字符串哈希处理冲突的开销较大，因此尽量让冲突几率低。

## 哈希函数

字符串往往较长，转换为的十进制数会极其庞大，此时我们就可以用哈希函数将极其庞大的数据范围映射到较小的数据范围。通常使用取模法的哈希函数，模数 $m$ 可以取 $2^{64}$，即哈希函数为 $f(x)=x\bmod 2^{64}$.

> C/C++ 的 unsigned long long 数据类型范围为 $[0,2^{64})$，因此如果模数取 $2^{64}$，那哈希函数可以直接忽略不写，让数据自然溢出则达到了取模效果。

除此之外也能选择一些其他组合，例如 $p=449,m=436522843$.

```cpp
typedef unsigned long long ull;
constexpr ull P = 449, MOD = 436522843;

ull get_hash(string &s)
{
    ull res = 0;
    for (int i = 0; i < s.size(); i++)
        res = (res * P % MOD + s[i]) % MOD;
    return res;
}
```

## 性质

字符串哈希具有类似**前缀和**的性质，即如果预处理了该字符串的每个前缀子串的哈希值，那么就可以在 $O(1)$ 内得到该字符串所有子串的哈希值。不过和前缀和不同的是，并不能直接相减，而是要乘上一个“偏移量”再减。

具体来说，将前缀哈希值储存在 $h_i$ 中，$h_i$ 代表字符串 $[1,i]$ 的前缀子串的哈希值。如果要求的子串左端点为第 $l$ 位，右端点为第 $r$ 位，则子串的哈希值 $h'$ 的计算公式：
$$
h'=h_r-p^{r-l+1}\cdot h_{l-1}
$$
代码实现时，为了加快效率，将 $p$ 的幂次预处理好保存到数组内。

------

原理仍然借助 $p$ 进制数来解释：

**我们已知的是：**第一行为 $p$ 进制数 $abcdef$ 的哈希值（仅作对比参考，实际算法是用不上的），第二行为 $0\sim2$ 子串的哈希值 $h_2$ ，第三行为 $0\sim4$ 子串的哈希值  $h[4]$ 。

**我们要求的是：**第四行 $3\sim4$ 字串的哈希值。
$$
\begin{array}{r}
(abcdef)_p & = & ap^5 & + & bp^4 & + & cp^3 & + & dp^2 & + & ep^1 & + & fp^0\\
(abc)_p    & = & ap^2 & + & bp^1 & + & cp^0 &   &      &   &      &   &     \\
(abcde)_p  & = & ap^4 & + & bp^3 & + & cp^2 & + & dp^1 & + & ep^0 &   &     \\
(de)_p     & = &      &   &      &   &      &   & dp^1 & + & ep^0 &   &     \\
\end{array}
$$
通过比对我们可以发现：$(de)_p=h_4-p^2\cdot h_2$

```cpp
typedef unsigned long long ull;
constexpr ull P = 449, MOD = 436522843;
constexpr int MAXN = 1e6 + 10;
ull p[MAXN], h[MAXN];
char s[MAXN]; // 下标从1开始，如果要用string注意下标修改

void init()
{
    p[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        p[i] = p[i - 1] * P % MOD;
        h[i] = (h[i - 1] * P % MOD + s[i]) % MOD;
    }
}

ull sub_hash(int l, int r)
{
    return (h[r] - h[l - 1] * p[r - l + 1] % MOD + MOD) % MOD;
}
```

